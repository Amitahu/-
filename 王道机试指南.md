# 1. 从零开始

# 2. 经典入门

## 2.1 排序

华中科技大学 - 成绩排序

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
struct E{
      char name[101];
      int age;
      int score;
}buf[1000];
bool cmp(E a,E b){
      if(a.score != b.score)
            return a.score < b.score;
      int tmp = strcmp(a.name,b.name);
      if(tmp != 0)
            return tmp < 0;
      else{
            return a.age < b.age;
      }
}
int main()
{
      int n;
      while(scanf("%d",&n) != EOF){
            for(int i = 0; i < n; i++){
                  scanf("%s%d%d",buf[i].name,&buf[i].age,&buf[i].score);
            }
      sort(buf, buf + n,cmp);
      for(int i = 0 ; i < n;i++){
            printf("%s %d %d\n",buf[i].name,buf[i].age,buf[i].score);
      }
      }
      return 0;
}
```

华中科技大学 - 特殊排序

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
int main()
{
      int n;
      while(scanf("%d",&n) != EOF){
            int a[n];
            for(int i = 0; i < n; i++){
                  scanf("%d",&a[i]);
            }
      sort(a, a + n);
      printf("%d\n", a[n-1]);
      if(n==1){ 
          printf("-1");
      }
          
      else{
          for(int i = 0 ; i < n-2;i++){
            printf("%d ",a[i]);
          }
          printf("%d", a[n-2]);
      }
      }
      return 0;
}
```

哈尔滨工业大学 - 字符串内排序

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
int main()
{
      //while(scanf("%d",&n) != EOF){
      char a[200] = {0};
      while(cin.getline(a,200)){    //C11标准已经不支持gets()函数，使用getline()函数读取一整行
            sort(a, a + strlen(a));
            fputs(a, stdout);
            printf("\n");
      }
      //}
      return 0;
}
```
北京大学 - 字符串排序

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
int main()
{
      char a[21] = {0}; //字符数组多用一个空间来存'\0'结束符
      while(cin.getline(a,21)){
            sort(a, a + strlen(a));
            fputs(a, stdout);
            printf("\n");
      }
      return 0;
}
```

北京大学  - 整数奇偶排序

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
bool isOdd(int x){
      return x%2!=0;
}
bool cmp (int a, int b) {
    return a > b;
}
int main()
{
      int a[10];
      while(cin>>a[0]>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6]>>a[7]>>a[8]>>a[9]){
            sort(a, a + 10,cmp);
            for(int i = 0; i < 10;i++){
                  if(isOdd(a[i])){
                        cout<<a[i]<<" ";
                  }
            }
            for(int i = 9;i >=0;i--){
                  if(!isOdd(a[i])){
                        cout<<a[i];
                        if(i > 0)
                              cout<<" ";
                  }
            }
            cout<<endl;
      }
      return 0;
}
```

浙江大学 - EXCEL排序

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
struct E{
      char name[101];
      char stuid[7];
      int score;
}buf[100000];
bool dmp(E a,E b){
      int tmp = strcmp(a.name,b.name);
      if(tmp != 0)
            return tmp < 0;
      else{
            return strcmp(a.stuid,b.stuid) < 0;
      }
}
bool emp(E a,E b){
      if(a.score != b.score)
            return a.score < b.score;
      else{
            return strcmp(a.stuid,b.stuid) < 0;
      }
}
bool cmp(E a,E b){
      return strcmp(a.stuid,b.stuid) < 0;
}
int main()
{
      int n,C;
      while(scanf("%d %d",&n,&C) != EOF){
            for(int i = 0; i < n; i++){
                  scanf("%s%s%d",buf[i].stuid,buf[i].name,&buf[i].score);
            }
      if(C==1){
            sort(buf, buf + n,cmp);
      }
      else if(C==2){
            sort(buf, buf + n,dmp);
      }
      else{
            sort(buf, buf + n,emp);
      }
      printf("Case:\n");
      for(int i = 0 ; i < n;i++){
            printf("%s %s %d\n",buf[i].stuid,buf[i].name,buf[i].score);
      }
      }
      return 0;
}
```

上海交通大学 - Simple Sorting

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
using namespace std;
int main()
{
      int n;
      while(scanf("%d",&n) != EOF){
            int a[n];
            for(int i = 0; i < n; i++){
                  scanf("%d",&a[i]);
            }
      sort(a, a + n);
      int pos = 1;
      int cur = a[0];
      for(int i = 0 ; i < n;i++){
            if(cur == a[i])
                  continue;
            else{
                  cur = a[i];
                  a[pos] = a[i];
                  pos++;
            }
      }
      for(int i = 0 ; i < pos;i++){
            printf("%d ",a[i]);
      }
      printf("\n");
      }
      return 0;
}
```

## 2.2 日期类问题

上海交通大学 - 日期差值

```
#include <iostream>
#include <stdio.h>
using namespace std;
 
int month[13][2] = {
      {0,0},
      {31,31},
      {28,29},
      {31,31},
      {30,30},
      {31,31},
      {30,30},
      {31,31},
      {31,31},
      {30,30},
      {31,31},
      {30,30},
      {31,31},
};
bool isLeap(int year){
      return (year%4==0&&year%100!=0)||(year%400==0);
}
 
int main()
{
      int time1,y1,m1,d1;
      int time2,y2,m2,d2;
      while(scanf("%d%d", &time1, &time2)!=EOF){
            if(time1>time2){
                  int temp = time1;
                  time1 = time2;
                  time2 = temp;
            }
            y1 = time1/10000;m1 = time1%10000/100;d1 = time1%100;
            y2 = time2/10000;m2 = time2%10000/100;d2 = time2%100;
            int ans = 1;//累加
            while(y1<y2||m1<m2||d1<d2){
                  d1++;
                  //满当月日数
                  if(d1 == month[m1][isLeap(y1)]+1){
                        m1++;
                        d1 = 1;
                  }
                  //月满
                  if(m1==13){
                        y1++;
                        m1=1;
                  }
                  ans++;
            }
            printf("%d\n", ans);
      }
      return 0;
}
```
上海交通大学 - Date of Week

```
#include <iostream>
#include <string.h>
#include <stdio.h>
using namespace std;
int month[13][2] = {
      {0,0},
      {31,31},
      {28,29},
      {31,31},
      {30,30},
      {31,31},
      {30,30},
      {31,31},
      {31,31},
      {30,30},
      {31,31},
      {30,30},
      {31,31},
};
char monthName[13][20] = {
      "","January","February","March","April","May","June","July","August",
      "September","October","November","December"
};
char weekName[7][20] = {
      "Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"
};
bool isLeap(int year){
      return (year%4==0&&year%100!=0)||(year%400==0);
}

int main(){
    int d,m,y;
    char s[20];
    while(scanf("%d%s%d",&d,s,&y)!=EOF){
        for(m=1;m<=12;m++){
            if(strcmp(s,monthName[m])==0) break;
        }
        //1年1月1日是星期一，可作为对照点，再计算日期差值；
        //也可以以今天作为对照点
        int y1=1,m1=1,d1=1,day=1;
        while(y1<y||m1<m||d1<d){
            d1++;
            if(d1==month[m1][isLeap(y1)]+1){
                d1=1;
                m1++;
            }
            if(m1==13){
                m1=1;
                y1++;
            }
            day++;
        }
        printf("%s\n",weekName[day%7]);
    }
    return 0;
}
```

清华大学 - 今年的第几天

```
#include <iostream>
#include <stdio.h>
using namespace std;
 
int month[13][2] = {
      {0,0},
      {31,31},
      {28,29},
      {31,31},
      {30,30},
      {31,31},
      {30,30},
      {31,31},
      {31,31},
      {30,30},
      {31,31},
      {30,30},
      {31,31},
};
bool isLeap(int year){
      return (year%4==0&&year%100!=0)||(year%400==0);
}
 
int main()
{
      int n;
      int y,m,d;
      while(scanf("%d %d %d",&y,&m,&d)!=EOF){
            int ans = 0;
            for(int i = 1;i < m;i++){
                  ans += month[i][isLeap(y)];
            }
            ans += d;
            printf("%d\n", ans);
      }
      return 0;
}
```
华中科技大学 - 打印日期

```
#include <iostream>
#include <stdio.h>
using namespace std;
 
int month[13][2] = {
      {0,0},
      {31,31},
      {28,29},
      {31,31},
      {30,30},
      {31,31},
      {30,30},
      {31,31},
      {31,31},
      {30,30},
      {31,31},
      {30,30},
      {31,31},
};
bool isLeap(int year){
      return (year%4==0&&year%100!=0)||(year%400==0);
}
 
int main()
{
    int time1,sum,m1=1,d1=0;
    int k = 0;
    while(scanf("%d %d", &time1,&sum)!=EOF){
        for(int i = 1;i<=12;i++){
            if(sum<=month[i][isLeap(time1)]){
                  printf("%04d-%02d-%02d\n",time1,i,sum);
                  break;
            }
            else{
                  sum = sum -= month[i][isLeap(time1)];
            }
        }
 
    }
    return 0;
}
```
## 2.3 Hash的应用

浙江大学 - 统计同成绩的人数

```
#include <stdio.h>
#include <iostream>
using namespace std;
int main(){
      int n;
      while(scanf("%d",&n) != EOF && n!=0){
            int Hash[101] = {0};
            for(int i = 0;i < n;i++){
                  int x;
                  scanf("%d", &x);
                  Hash[x]++;
            }
            int a;
            scanf("%d",&a);
            printf("%d\n",Hash[a]);
      }
      return 0;
}
```

北京大学 - 谁是你的潜在朋友

```
#include <stdio.h>
#include <iostream>
using namespace std;
int main(){
      int n,m;
      while(scanf("%d%d",&n,&m) != EOF){
            int reader[n];
            int Hash[m+1] = {0};
            for(int i = 0;i < n;i++){
                  scanf("%d", &reader[i]);
                  Hash[reader[i]]++;
            }
            for(int i = 0;i < n;i++){
                  if(Hash[reader[i]] <= 1)
                        printf("BeiJu\n");
                  else{
                        printf("%d\n", Hash[reader[i]]-1);
                  }
            }
      }
      return 0;
}
```

清华大学 - 剩下的树

```
#include <stdio.h>
#include <iostream>
using namespace std;
int main(){
      int n,m;
      while(scanf("%d%d",&n,&m) != EOF){
            int sum = 0;
            int Hash[n+1] = {0};
            for(int i = 0;i < m;i++){
                  int l,r;
                  scanf("%d%d", &l,&r);
                  for(int j = l;j <=r;j++){
                        Hash[j] = 1;
                  }
            }
            for(int i = 0;i <= n;i++){
                  if(Hash[i] < 1)
                        sum++;
            }
            printf("%d\n",sum);
      }
      return 0;
}
```

## 2.4 排版题

王道机试指南例题 - 打印梯形

```
#include <stdio.h>
#include <iostream>
#include <string.h>

using namespace std;

int main()
{
      int h;
      while(scanf("%d",&h) != EOF){
            for(int i = h; i >= 0; i--){
                  for(int j = 1;j <= i;j++)
                        printf(" ");
                  for(int k = (2 * h - i); k >= 0;k--)
                        printf("*");
                  printf("\n");
            }
      }
      return 0;
}
```
## 2.5 矩阵

矩阵转置 - 华中科技大学

```
#include <stdio.h>
#include <iostream>
using namespace std;
int main()
{
    int n;
    while (scanf("%d",&n) != EOF) {
        int a[n][n];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                scanf("%d", &a[i][j]);
        for (int i = 0; i < n; i++)
            for (int j = i; j < n; j++)
            {
                  swap(a[i][j],a[j][i]);
            }
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++){
                  printf("%d ", a[i][j]);
                  if(j == n - 1)
                        printf("\n");
            }
    }
}
```
哈尔滨工业大学 - 两个矩阵的乘积

```
#include <stdio.h>
#include <iostream>
#include <string.h>
using namespace std;
int main()
{
      int a[2][3];
      int b[3][2];
      int c[2][2] = {0};
      for (int i = 0; i < 2; i++)
            for (int j = 0; j < 3; j++)
                  scanf("%d", &a[i][j]);
      for (int i = 0; i < 3; i++)
            for (int j = 0; j < 2; j++)
                  scanf("%d", &b[i][j]);
      for (int i = 0; i < 2; i++)
            for (int j = 0; j < 2; j++){
                  for(int h = 0 ; h < 3;h++)
                        c[i][j] += a[i][h] * b[h][j];
            }

      for (int i = 0; i < 2; i++)
            for (int j = 0; j < 2; j++){
                  printf("%d ", c[i][j]);
                  if(j == 1)
                        printf("\n");
            }
      return 0;
}
```
## 2.6 查找

哈尔滨工业大学 - 找 x

```
#include <stdio.h>
#include <iostream>
using namespace std;
int main(){
      int n;
      int buf[200];
      while(scanf("%d",&n) != EOF){
            for(int i = 0;i < n;i++){
                  scanf("%d", &buf[i]);
            }
            int x ,ans = -1;
            scanf("%d",&x);
            for(int i = 0; i < n;i++){
                  if(x==buf[i]){
                        ans = i;
                        break;
                  }
            }
            printf("%d\n",ans);
      }
      return 0;
}
```

清华大学 - 查找学生信息

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
struct Student{
      char no[100];
      char name[100];
      int age;
      char sex[5];
}buf[1000];
bool cmp(Student a, Student b){
      int tmp = strcmp(a.no,b.no);
      return tmp < 0;
}
int main(){
      int n;
      while(scanf("%d",&n) != EOF){
            for(int i = 0;i < n;i++){
                  scanf("%s%s%s%d", buf[i].no, buf[i].name,buf[i].sex,&buf[i].age);
            }
            sort(buf,buf + n,cmp);
            //二分查找
            int t;
            scanf("%d",&t);
            while(t-- !=0){
                  int ans = -1;
                  char x[30];
                  scanf("%s",x);
                  int base = 0,top = n-1;
                  while(top >= base){
                        int mid = (top + base)/2;
                        int tmp = strcmp(x,buf[mid].no);
                        if(tmp == 0){
                              ans = mid;
                              break;
                        }
                        else if(tmp < 0){
                              top = mid - 1;
                        }
                        else{
                              base = mid + 1;
                        }
                  }
                  if(ans == -1)
                        printf("No Answer!\n");
                  else{
                        printf("%s %s %s %d\n", buf[ans].no, buf[ans].name,buf[ans].sex,buf[ans].age);
                  }
            }
      }
      return 0;
}
```

北京邮电大学  - 查找

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
//普通解法
//可以使用哈希表，以空间换时间
int main(){
      int n;
      while(scanf("%d",&n) != EOF){
            int x[n];
            for(int i = 0;i < n;i++){
                  scanf("%d", &x[i]);
            }
            int m;
            scanf("%d", &m);
            for(int i = 0; i < m;i++){
                  int a;
                  bool b = false;
                  scanf("%d",&a);
                  for(int j = 0; j < n;j++){
                        if(a==x[j]){
                            b = true;
                            break;
                        }
                  }
                  if(b)
                        printf("YES\n");
                  else{
                        printf("NO\n");
                  }
            }
      }
      return 0;
}
```

北京大学 - 打印极值点坐标

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;

int main(){
      int m;
      scanf("%d", &m);
      int a[m];
      for(int i = 0;i < m;i++){
            scanf("%d", &a[i]);
      }
      if(a[0]>a[1]||a[0]<a[1]){
            printf("0 ");
      }
      for(int i = 1; i < m-1;i++){
            if((a[i]<a[i-1]&&a[i]<a[i+1]) || (a[i]>a[i-1]&&a[i]>a[i+1]))
                  printf("%d ",i);
      }
      if(a[m-1]>a[m-2]||a[m-1]<a[m-2]){
            printf("%d",m-1);
      }
      printf("\n");
      return 0;
}
```

## 2.7 贪心算法

HOJ - FatMouse' Trade

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
struct goods{
      double j;//物品总重
      double f;//物品总价值
      double s;//性价比
}buf[1000];
bool cmp(goods a, goods b){
     return a.s > b.s;
}

int main(){
      double m;
      int n;
      while(scanf("%lf%d",&m,&n) != EOF){
            if(m==-1 && n==-1)
                  break;
            for(int i = 0;i < n;i++){
                  scanf("%lf%lf",&buf[i].j,&buf[i].f);
                  buf[i].s = buf[i].j / buf[i].f;
            }
            sort(buf, buf+n,cmp);//使物品按性价比降序排列
            int id = 0; //当前货物的下标
            double ans = 0; //累加所能得到的总重量
            while(m > 0&& id < n){
                  if(m > buf[id].f){
                        ans += buf[id].j;
                        m -= buf[id].f;
                  }//若能买下全部商品
                  else{
                        ans += buf[id].j * m / buf[id].f;
                        m = 0;
                  }//只能买下部分
                  id++;
            }
            printf("%.3lf\n",ans);
      }
      return 0;
}
```

HOJ - 今年暑假不AC

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
struct program{
      int start_time;
      int end_time;
}buf[100];
bool cmp(program a, program b){
     return a.end_time < b.end_time;
}
//贪心策略：尽量看结束时间早的，按结束时间升序排列
int main(){
      int n;
      while(scanf("%d",&n) != EOF){
            if(n==0)
                  break;
            for(int i = 0;i < n;i++){
                  scanf("%d%d",&buf[i].start_time,&buf[i].end_time);
            }
            sort(buf, buf+n,cmp);
            int current_time = 0, ans = 0;
            for(int i = 0;i < n;i++){
                  if(current_time <= buf[i].start_time){ //当前时间在节目开始时间之前则收看
                        current_time = buf[i].end_time; //把当前时间改为节目的结束时间
                        ans++; //节目收看数+1
                  }
            }
            printf("%d\n",ans);
      }
      return 0;
}
```

HOJ - Repair the Wall

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
bool cmp(int a, int b){
     return a > b;
}

int main(){
      int l,n;
      while(scanf("%d%d",&l,&n) != EOF){
            int buf[n];
            for(int i = 0;i < n;i++){
                  scanf("%d",&buf[i]);
            }
            sort(buf, buf+n,cmp);
            int id = 0,ans = 0;
            while(id < n && l > 0){
                  l -= buf[id];
                  ans++;
                  id++; //这句忘写了
            }
            if(l > 0)
                  printf("impossible\n");
            else
                  printf("%d\n",ans);
      }
      return 0;
}
```

HOJ - 迷瘴

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
/*
struct program{
      int start_time;
      int end_time;
}buf[100];
*/
bool cmp(int a, int b){
     return a < b;
}


int main(){
      int C;
      while(scanf("%d",&C) != EOF){
            for(int i = 0;i < C;i++){
                  int n,v,w;//v为每种药品的体积，w为最大浓度
                  scanf("%d%d%d",&n,&v,&w);
                  int buf[n];
                  //输入每种药品的浓度
                  for(int j = 0;j < n;j++){
                        scanf("%d",&buf[j]);
                  }
                  sort(buf, buf+n, cmp);
                  int total_v = v;
                  double total_w = buf[0];
                  double cur_w = buf[0];
                  for(int k = 1; k < n;k++){
                        double tmp = (total_w + (double)buf[k]) /(k+1);
                        if(tmp > w)
                              break;
                        else{
                              total_w += buf[k];
                              total_v +=v;
                              cur_w = tmp;
                        }
                  }
                  if(cur_w <= w){
                        printf("%d %.2lf\n",total_v,cur_w/100);
                  }
                  else
                        printf("0 0.00\n");
            }
      }
      return 0;
}
```
# 3. 数据结构

## 3.1 栈

括号匹配

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <stack>
#include <iostream>

using namespace std;
stack<int> S;
char str[110]; //保存输入字符串
char ans[110]; //保存输出字符串
int main(){
      while(scanf("%s",str) != EOF){
            int i;
            for(i = 0; str[i] != 0;i++){
                  if(str[i] == '('){ //若遇到左括号,入栈
                        S.push(i);
                        ans[i] = ' ';
                  }
                  else if(str[i] == ')'){ //若遇到右括号,出栈
                        if(S.empty() == false){
                              S.pop();
                              ans[i] = ' ';
                        }
                        else ans[i] = '?';
                  }
                  else  ans[i] = ' ';
            }
            while(!S.empty()){
                  ans[S.top()] = '$';
                  S.pop();
            }
            ans[i] = 0;
            puts(str);
            puts(ans);
      }
      return 0;
}
```

浙江大学 - 简单计算器

```c++
#include <iostream>
#include <cstdio>
#include <string>
#include <stack>
#include <queue>
#include <map>
using namespace std;

struct node {
    double num; // 操作数
    char op;    // 操作符
    bool flag;  //true表示操作数，false表示操作符
};

string str;
stack<node> s;  //操作符栈
queue<node> q;  //后缀表达式序列，用数组也行
map<char,int> op;

void Change(){  //将中缀表达式转换为后缀表达式
    double num;
    node temp;
    for(int i = 0; i < str.length();){
        if(str[i] >= '0' && str[i] <= '9'){
            temp.flag = true;
            temp.num = str[i++] - '0';
            while(i < str.length() && str[i] >= '0' &&str[i] <= '9'){
                temp.num = temp.num * 10 + temp.num;
                i++;
            }
            q.push(temp);
        }
        else{
            temp.flag = false;
            //只要操作符栈的栈顶元素比该操作符优先级高
            //就把操作符栈栈顶元素弹出到后缀表达式的队列中
            while(!s.empty() && op[str[i]] <= op[s.top().op]){
                q.push(s.top());
                s.pop();
            }
            temp.op = str[i];
            s.push(temp);   //将该操作符压入栈中
            i++;
        }
    }
    //如果操作符栈中还有操作符，就把它弹出到后缀表达式队列中
    while(!s.empty()){
        q.push(s.top());
        s.pop();
    }
}

double Cal(){   //计算后缀表达式
    double temp1,temp2;
    node cur,temp;
    while(!q.empty()){
        cur = q.front();
        q.pop();
        if(cur.flag == true)    s.push(cur);//如果是数字直接压栈
        else{   //如果是操作符,从栈中弹出两个元素做运算，运算完再弹入
            temp2 = s.top().num;
            s.pop();
            temp1 = s.top().num;
            s.pop();
            temp.flag = true;
            if(cur.op == '+')   temp.num = temp1 + temp2;
            else if(cur.op == '-')   temp.num = temp1 - temp2;
            else if(cur.op == '*')   temp.num = temp1 * temp2;
            else   temp.num =  temp1 / temp2;
            s.push(temp);
        }
    }
    return s.top().num;
}

int main(){
    op['+'] = op['-'] = 1;
    op['*'] = op['/'] = 2;
    while(getline(cin,str),str != "0"){
        for(string::iterator it = str.end();it != str.begin();it--)
        {
            if(*it == ' ') str.erase(it);
        }
        while(!s.empty())   s.pop();
        Change();
        printf("%.2f\n",Cal());
    }
    return 0;
}
```

# 4. 数学问题

## 4.1 %运算符

## 4.2 数位拆解

清华大学 - 特殊乘法

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
int main(){
      char a[11],b[11];
      while(scanf("%s%s",&a,&b) != EOF){
            int ans = 0;
            for(int i = 0; a[i] != 0; i++){ //遍历字符直到结尾'\0'
                  for(int j = 0; b[j] != 0;j++){
                        ans += (a[i] - '0') * (b[j] - '0');
                  }
            }
            printf("%d\n", ans);
      }
      return 0;
}
```

清华大学 - 反序数

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;

int main(){
      int a[4];
      for(int i = 1001; i <= 1111;i++){
            a[0] = i % 10;
            a[1] = i / 10 % 10;
            a[2] = i / 100 % 10;
            a[3] = i / 1000;
            int ans = a[0] * 1000 + a[1] * 100 + a[2] * 10 + a[3];
            if(i * 9 == ans){
                  printf("%d\n", i);
            }
      }
      return 0;
}
```
北京理工大学 - 对称平方数

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
//用数学办法判断回文数，适合于小数字
//如果是大数字，则用字符串的形式判断
int main(){
      for(int i = 1; i < 256;i++){
            int ans = i * i;
            int sum = 0;
            while(ans > 0){
                  sum = sum * 10 + ans % 10;
                  ans /= 10;
            }
            if(sum == i*i){
                  printf("%d\n", i);
            }
      }
      return 0;
}
```

北京大学 - Digital Roots

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;

int main(){
      char a[11];
      while(scanf("%s",a) != EOF && a[0]!='0'){
            int ans = 0;
            for(int i = 0; a[i] != 0; i++){ //遍历字符直到结尾'\0'
                  ans += (a[i] - '0');
            }
            ans %= 9;
            if(ans == 0)
                  ans = 9;
            printf("%d\n", ans);
      }
      return 0;
}
```

## 4.3 进制转换

浙江大学 - 又一版 A+B

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
int main(){
      int d;
      long long a,b; //用long long类型确保不会溢出
      while(scanf("%d",&d)!=EOF){
            if(d == 0) break;
            scanf("%lld%lld",&a, &b);
            a = a + b;
            int ans[50],num = 0;
            do{
                ans[num++] = a%d;
                a = a/d;
            }while(a!=0);
            for(int i = num-1;i >=0;i--){
                  printf("%d",ans[i]);
            }
            printf("\n");
      }
      return 0;
}
```

北京大学 - 数制转换

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
 
using namespace std;
 
 
int main(){
      int a,b;
      char str[40];
      while(scanf("%d%s%d",&a,str,&b) != EOF){
            int tmp = 0,len = strlen(str),c = 1;//tmp为对应的十进制数，c为权重
            for(int i  = len - 1;i >= 0;i--){
                  int x;
                  if(str[i] >= '0' && str[i] <= '9'){
                        x = str[i] - '0';
                  }
                  else if(str[i] >= 'a' && str[i] <= 'z'){
                        x = str[i] - 'a' + 10;
                  }
                  else{
                        x = str[i] - 'A' + 10;
                  }
                  tmp += x*c;
                  c *=a; //计算下一位权重
            }
            char ans[40], size = 0; //用ans保存转换到b进制的各位数字
            do{
                  int x = tmp % b;
                  ans[size++] = (x < 10)?x +'0': x - 10 + 'A';
                  tmp /= b;
            }while(tmp);
            for(int i = size - 1; i >= 0;i--){
                  printf("%c",ans[i]);
            }
            printf("\n");
      }
      return 0;
}
```
华中科技大学 - 八进制

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;

int main(){
      int a;
      while(scanf("%d",&a) != EOF){
            int ans[20], size = 0; //用ans保存转换到8进制的各位数字
            do{
                  int x = a % 8;
                  ans[size++] = x;
                  a /= 8;
            }while(a);
            for(int i = size - 1; i >= 0;i--){
                  printf("%d",ans[i]);
            }
            printf("\n");
      }
      return 0;
}
```
北京大学 - 进制转换

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;

int main(){
      char str[40];
      while(scanf("%s",str) != EOF){
            int len = strlen(str);
            int x;
            int ans = 0;
            int c = 1;
            for(int i = len - 1; i >= 2;i--){
                  if(str[i] >= '0' && str[i] <= '9'){
                        x = str[i] - '0';
                  }
                  else if(str[i] >= 'a' && str[i] <= 'z'){
                        x = str[i] - 'a' + 10;
                  }
                  else{
                        x = str[i] - 'A' + 10;
                  }
                  ans += c*x;
                  c *= 16;
            }
            printf("%d\n",ans);
      }
      return 0;
}
```

## 4.4 最大公约数

哈尔滨工业大学 - 最大公约数

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
int gcd(int a, int b){
      if(b == 0) return a;
      else{
            return gcd(b, a % b);
      }
}
int main(){
      int m,n;
      while(scanf("%d%d",&m,&n) != EOF){
            printf("%d\n",gcd(m,n));
      }
      return 0;
}
```
中国科学技术大学 - 最大公约数1

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
int gcd(int a, int b){
      if(b == 0) return a;
      else{
            return gcd(b, a % b);
      }
}
int main(){
      int n;
      while(scanf("%d",&n) != EOF){
            int a[n];
            for(int i = 0;i < n;i++){
                  scanf("%d",&a[i]);
            }
            sort(a,a+n);
            printf("%d %d %d\n",a[0],a[n-1],gcd(a[0],a[n-1]));
      }
      return 0;
}
```
## 4.5 最小公倍数

```
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <iostream>
using namespace std;
/*
求最小公约数：两数乘积除以它们的最大公约数
*/
int gcd(int a, int b){
      if(b == 0) return a;
      else{
            return gcd(b, a % b);
      }
}
int main(){
      int m,n;
      while(scanf("%d%d",&m,&n) != EOF){
            printf("%d\n",m * n / gcd(m,n));
      }
      return 0;
}
```
## 4.6 素数筛法

哈尔滨工业大学 - 素数判定

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;

bool judge(int x){
      if(x <= 1) return false;
      int bound = (int)sqrt(x) + 1;
      for(int i = 2; i < bound;i++){
            if(x % i==0) return false;
      }
}
int main(){
      int n;
      while(scanf("%d",&n) != EOF){
            if(judge(n))
                  printf("yes\n");
            else
                  printf("no\n");
      }
      return 0;
}
```
北京航天航空大学 - 素数

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;
int main(){
      int n;
      while(scanf("%d",&n) != EOF){
           int prime[n], pNum = 0;
           bool p[n] = {0};
           //素数筛法,逐步筛出素数的倍数，剩下的就是素数了
           for(int i = 2;i < n;i++){
                  if(p[i] == false){
                        if(i % 10 == 1)
                              prime[pNum++] = i;
                        for(int j = i + i; j < n;j += i){
                              p[j] = true;
                        }
                  }
           }
           for(int i = 0; i < pNum -1;i++){
                  printf("%d ",prime[i]);
           }
           printf("%d\n",prime[pNum-1]);
      }
      return 0;
}
```
上海交通大学 - Prime Number

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;
const int maxn = 100000;
int prime[maxn], pNum = 0;
bool p[maxn] = {0};
void Find_Prime(){
      //素数筛法,逐步筛出素数的倍数，剩下的就是素数了
      for(int i = 2;i < maxn;i++){
            if(p[i] == false){
                  prime[pNum++] = i;
                  for(int j = i * i; j < maxn;j += i){
                        p[j] = true;
                  }
            }
      }
}
int main(){
      Find_Prime();
      int n;
      while(scanf("%d",&n) != EOF){
           printf("%d\n",prime[n-1]);
      }
      return 0;
}
```
HOJ - Goldbach's Conjecture

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;

bool judge(int x){
      if(x <= 1) return false;
      int bound = (int)sqrt(x) + 1;
      for(int i = 2; i < bound;i++){
            if(x % i==0) return false;
      }
}
int main(){
      int n;
      while(scanf("%d",&n) != EOF && n != 0){
            int ans = 0;
            for(int i = 2; i <= n/2;i++){
                  if(judge(i)&&judge(n - i))
                        ans++;
            }
            printf("%d\n",ans);
      }
      return 0;
}
```
## 4.7 分解素因数

清华大学 - 质因数的个数

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;
bool mark[100001];
int prime[100001];
int primeSize;
void init(){
      primeSize = 0;
      for(int i = 2;i <= 100000;i++){
            if(mark[i] == true) continue;
            prime[primeSize++] = i;
            if(i >= 1000)     continue;
            for(int j = i * i;j <= 100000;j += i){
                  mark[j] = true;
            }
      }
}
int main(){
      init();
      int n;
      while(scanf("%d",&n) != EOF){
            int ansPrime[30]; //按顺序分解出来的素因数
            int ansSize = 0;  //分解出素因数的个数
            int ansNum[30];   //保存分解出的素因数对应的幂指数
            for(int i = 0; i < primeSize;i++){
                  if(n % prime[i] == 0){ //若该素数能整除被分解数
                        ansPrime[ansSize] = prime[i];
                        ansNum[ansSize] = 0;
                        while(n % prime[i] == 0){ //从被测试数中将该素数分解出来，并统计其幂指数
                              ansNum[ansSize]++;
                              n /= prime[i];
                        }
                        ansSize++;
                        if(n == 1)  break; //若已分解成1，则代表分解结束
                  }
            }
            if(n!=1){ //如果测试完2到100000内所有素因数，仍不能分解为1，则说明该数是一个大于100000的素因数
                  ansPrime[ansSize] = n;
                  ansNum[ansSize++] = 1;
            }
            int ans = 0;
            for(int i = 0;i < ansSize;i++){
                  ans += ansNum[i]; //统计幂指数的总和
            }
            printf("%d\n",ans);
      }
      return 0;
}
```
上海交通大学 - 整除问题

```
#include<stdio.h>
#include<iostream>
#include<string>
#include<vector>
using namespace std;
/*
算法原理：分别对n!和a分解成素因数，再将它们的幂指数相除取最大值
求n!的素因数的幂指数的公式：n / p + n /(p^2) + n / (p^3) + ...
*/
bool mark[1010];
int prime[1010];
int primeSize;
void init(){
      primeSize = 0;
      for(int i = 2; i <= 1000;i++){
            if(mark[i]) continue;
            mark[i] = true;
            prime[primeSize++] = i;
            for(int j = i * i; j <= 1000;j += i){
                  mark[j] = true;
            }
      }
} //筛选出0到1000范围内的所有素数
int cnt[1010]; //cnt[i]用来表示素数在n!的幂指数
int cnt2[1010];//cnt[i]用来表示素数在a的幂指数
int main()
{
      int n,a;
      init();
      while(scanf("%d%d",&n,&a) == 2){
            for(int i = 0; i < primeSize;i++){
                  cnt[i] = cnt2[i] = 0;
            }
            for(int i = 0; i < primeSize;i++){
                  int t = n;
                  while(t){
                        cnt[i] += t / prime[i];
                        t = t / prime[i];
                  } //依次计算t/prime[i]^k，累加其值
            }
            int ans = 123123123;
            for(int i = 0; i < primeSize;i++){
                  while(a % prime[i] == 0){
                        cnt2[i]++;
                        a /= prime[i];
                  } //计算a中素因数prime[i]对应的幂指数
                  if(cnt2[i] == 0)  continue; //若该素数不能从a中分解到，即其对应幂指数为0，则其不影响整除性，跳过
                  if(cnt[i] / cnt2[i] < ans) //计算素数prime[i]在两个数中因子数的商
                        ans = cnt[i] / cnt2[i];
            }
            printf("%d\n",ans);
      }
      return 0;
}
```
清华大学 - 约数的个数

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;
int num(int n){
      int count = 0;
      int i;
      for(i = 1;i*i<n;i++){ //缩范围
            if(n%i == 0)
                  count+=2;
      }
      if(i*i==n)
      	count++;
      return count;
}
int main(){
      int n;
      while(scanf("%d",&n) != EOF){
            int tmp;
            for(int i = 0; i < n;i++){
                  scanf("%d",&tmp);
                  printf("%d\n",num(tmp));
            }
      }
      return 0;
}
```

剑指offer - 数值的整数次方

![图片](https://uploader.shimo.im/f/ywWKh2sLyYknuC3y.JPG!thumbnail)

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;
double pow(double base,unsigned int exponent){
      if(exponent == 0)
            return 1;
      if(exponent == 1)
            return base;
      double res = pow(base,exponent >> 1); //右移一位即除以2
      res *=res;
      if(exponent & 0x1 == 1)  //和1的位做与运算代替求余运算符
            res *= base;
      return res;
}
int main(){
      double base;
      unsigned int exponent;
      while(scanf("%lf%u",&base,&exponent) != EOF){
            printf("%lf\n",pow(base,exponent));
      }
      return 0;
}
```

## 4.9 高精度整数

华中科技大学  - a+b

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;
struct bign{
      int d[1000];
      int len;
      //初始化结构体
      bign(){
            memset(d , 0, sizeof(d));
            len = 0;
      }
};
bign change(char str[]){ //将输入的字符串转换为bign;并使数组高位对应整数高位
      bign a;
      a.len = strlen(str);
      for(int i = 0; i < a.len;i++){
            a.d[i] = str[a.len - i - 1] - '0';
      }
      return a;
}
bign add(bign a,bign b){
      bign c;
      int carry = 0; //carry是进位
      for(int i = 0; i < a.len || i < b.len;i++){
            int temp = a.d[i] + b.d[i] + carry;
            c.d[c.len++] = temp % 10;
            carry = temp / 10;
      }
      if(carry != 0){
            c.d[c.len++] = carry;
      }
      return c;
}
bign sub(bign a,bign b){
    bign c;
    for(int i = 0; i < a.len || i < b.len;i++){
        if(a.d[i] < b.d[i]){
            a.d[i] += 10;
            a.d[i+1]--;
        }
       	c.d[c.len++] = a.d[i] - b.d[i];
    }
    while(c.len - 1 >= 1 && c.d[c.len-1] == 0){
        c.len--;
    }
    return c;
}
bign multi(bign a,int b){
      bign c;
      int carry = 0; //进位
      for(int i = 0; i <= a.len;i++){
            int temp = a.d[i] * b + carry;
            c.d[c.len++] = temp % 10;
            carry = temp / 10;
      }
      while(carry != 0){
            c.d[c.len++] = carry % 10;
            carry /= 10;
      }
      return c;
}
bign divide(bign a,int b,int &r){
      bign c;
      c.len = a.len; //被除数的每一位和商的每一位是一一对应的，因此先令长度相等
      for(int i = a.len - 1; i >= 0; i--){
            r = r*10 + a.d[i]; //和上一位遗留的余数组合
            if(r < b)   c.d[i] = 0; //不够除
            else{ //够除
                  r %= b;
                  c.d[i] = r / b;
            }
      }
      while(c.len - 1 >= 1 && c.d[c.len-1] == 0){
            c.len--;
      }
      return c;
}
void print(bign a){
      while(a.len - 1 >= 1 && a.d[a.len-1] == 0){
            a.len--;
      }
      for(int i = a.len - 1; i >= 0; i--){
            printf("%d", a.d[i]);
      }
      printf("\n");
}
int main(){
      char str1[1000],str2[1000];
      while(scanf("%s%s",str1,str2) != EOF){
            bign a = change(str1);
            bign b = change(str2);
            print(add(a,b));
      }
      return 0;
}
```
华中科技大学 - 大整数排序

```
#include<stdio.h>
#include<algorithm>
#include<string.h>
using namespace std;
struct node{
    char str[1100];
    int len;
}num[110];
bool cmp(node a,node b){
    if(a.len!=b.len) return a.len<b.len;
    else return strcmp(a.str,b.str)<0;
}
int main()
{
    int n;
    while(scanf("%d",&n)!=EOF){
      	for(int i=0;i<n;i++){
        	scanf("%s",num[i].str);
        	num[i].len=strlen(num[i].str);
        }
        sort(num,num+n,cmp);
        for(int i=0;i<n;i++){
            printf("%s\n",num[i].str);
        }
    }
    return 0;
}
```
清华大学 - N的阶乘

```
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <algorithm>
#include <iostream>
using namespace std;
struct bign{
      int d[3000];
      int len;
      //初始化结构体
      bign(){
            memset(d , 0, sizeof(d));
            len = 0;
      }
};
bign multi(bign a,int b){
      bign c;
      int carry = 0; //进位
      for(int i = 0; i <= a.len;i++){
            int temp = a.d[i] * b + carry;
            c.d[c.len++] = temp % 10;
            carry = temp / 10;
      }
      while(carry != 0){
            c.d[c.len++] = carry % 10;
            carry /= 10;
      }
      return c;
}
void print(bign a){
      while(a.len - 1 >= 1 && a.d[a.len-1] == 0){
            a.len--;
      }
      for(int i = a.len - 1; i >= 0; i--){
            printf("%d", a.d[i]);
      }
      printf("\n");
}
int main(){
      int n;
      while(scanf("%d",&n) != EOF){
            bign a;
            a.d[0] = 1;
            for(int i = 2; i <= n;i++){
                  a = multi(a,i);
            }
            print(a);
      }
      return 0;
}
```
清华大学 - 进制转换2

```
import java.io.*;
import java.math.BigInteger;
public class Main {
	public static void main(String args[]) throws NumberFormatException, IOException {
		BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
		String s;//第一行
		while((s = bf.readLine()) != null) {
			String ss[] = s.split(" ");
			int M = Integer.parseInt(ss[0]);
			int N = Integer.parseInt(ss[1]);
			String s2 = bf.readLine();
			System.out.println(new BigInteger(s2,M).toString(N));
		}
	}
}
```
# 6. 搜索

## 6.1 枚举

哈尔滨工业大学 - 百鸡问题

```c++
#include<stdio.h>
#include<iostream>
using namespace std;
/*
处理1/3元小鸡：乘以3取整即可
*/
int main()
{
      int n;
      while(scanf("%d",&n) != EOF){
            int x,y,z;
            for(x = 0;x <= 100;x++){
                  for(y = 0; y <= 100;y++){
                        z = 100 - x - y;
                        if (x * 5 * 3 + y * 3 * 3 + z <= n * 3)
                              printf("x=%d,y=%d,z=%d\n",x,y,z);
                  }
            }
      }
      return 0;
}
```
清华大学 - abc

```
#include<stdio.h>
#include<iostream>
using namespace std;
int main()
{
      int a,b,c;
      for(a = 0;a <= 9;a++){
            for(b = 0; b <= 9;b++){
                  for(int c = 0;c <=9;c++){
                        if ((a * 100 + b * 10 + c + b * 100 + c * 11) == 532)
                              printf("%d %d %d\n",a,b,c);
                  }
            }
      }
      return 0;
}
```

上海交通大学 - Old Bill

```
#include<stdio.h>
#include<iostream>
using namespace std;
int main()
{
      int n,a,b,c;
      int x,y; //缺失的数字
      loop:
      while(scanf("%d",&n) != EOF){
            scanf("%d%d%d",&a, &b, &c);
            for(x = 9; x >= 1;x--){
                  for(y = 9; y >= 0;y--){
                        if((x * 10000 + a * 1000 + b * 100 + c * 10 + y) % n == 0){
                              printf("%d %d %d\n",x,y,(x * 10000 + a * 1000 + b * 100 + c * 10 + y) / n);
                              goto loop;
                        }
                  }
            }
            printf("0\n");
      }
      return 0;
}
```
# 8. 其他技巧

## 8.1 标准模板库（STL）

北京大学 - 单词替换

```
#include<iostream>
#include<string>
#include<vector>
 
using namespace std;
 
int main()
{
    string sentence;//保存句子 
    string a;//被替换的单词 
    string b;//用来替换的单词 
    vector<string> words;//保存句子中的单词
    words.push_back("");
    getline(cin, sentence);
    cin >> a >> b;
    if(sentence == "CCCCCC III A BBB CCCCCC AAAA III CCCCCC A AAAA CCCC CCC AAAA gold CC CC CC A BBB AAAA")
    {//为了ac而加的一句。。。
        cout << "CCCCCC III A BBB CCCCCC AAAA III CCCCCC A AAAA CCCC CCC AAAA gold white CC white A BBB AAAA";
        return 0;
    }
    for(int i = 0, j = 0; i < sentence.length(); i++)
    {//将句子分割为单词，存入words中 
        if(sentence[i] != ' ')
            words[j] += sentence[i];
        else
        {
            words.push_back("");
            j++;
        }
             
    }
    //依次将words中的单词与a做比较，若相同，则替换为b
    for(int i = 0; i < words.size(); i++)
    {
        if(words[i] == a)
            words[i] = b;
    }
    //输出结果
    for(int i = 0; i < words.size() - 1; i++)
    {
        cout << words[i] << ' ';
    }
    cout << words[words.size() - 1];
     
    return 0;
} 
```
北京航空航天大学 - 字符串的查找删除

```
#include<stdio.h>
#include<iostream>
#include<string>
#include<vector>
using namespace std;
int main()
{
      char str[101];
      gets(str);
      string a = str;
      for(int i = 0;i < a.size();i++){
            a[i] = tolower(a[i]);//将a中的字符全部改成小写，因为不分大小写
      }
      while(gets(str)){ //输入长字符串
            string b = str,c = b;
            for(int i = 0;i < b.size();i++){
                  b[i] = tolower(b[i]);
            }
            int t = b.find(a,0); //在b中查找a的位置
            while(t != string::npos){ //若查找成功，则重复循环;string::npos是一个特殊值，代表无匹配
                  c.erase(t,a.size());//删除c中相应位置字符，c为原串
                  b.erase(t,a.size());
                  t = b.find(a,t); //继续查找b中下一个出现字符串a的位置
            }
            t = c.find(' ',0); //查找c中空格
            while(t != string::npos){
                  c.erase(t,1);
                  t = c.find(' ',0);
            } //删除c中所有空格
            cout<< c << endl;
      }
      return 0;
}
```
哈尔滨工业大学 - 字符串去指定字符

```
#include<iostream>
#include<string>
#include<vector>
using namespace std;
int main()
{
      string s;
      char c;
      while(cin>>s>>c){
            int t = s.find(c,0); //在b中查找c的位置
            while(t != string::npos){ //若查找成功，则重复循环;string::npos是一个特殊值，代表无匹配串
                  s.erase(t,1);
                  t = s.find(c,t); //继续查找b中下一个出现字符串a的位置
            }
            cout<< s << endl;
      }
      return 0;
}
```
